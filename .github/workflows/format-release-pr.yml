name: Format Release PR

on:
  pull_request:
    types: [opened, synchronize]
    branches:
      - master
      - release/3.x
      - release/4.x

permissions:
  contents: read
  pull-requests: write

jobs:
  format-release-pr:
    if: startsWith(github.head_ref, 'release-please--')
    runs-on: ubuntu-latest
    steps:
      - name: Format PR body
        uses: actions/github-script@v8
        with:
          script: |
            const prNumber = context.payload.pull_request.number;
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            let body = pr.body;
            if (!body) {
              console.log('No PR body found');
              return;
            }

            // Check if already formatted (has scope headers like "**api:**")
            if (/^\*\*[a-z-]+:\*\*$/m.test(body)) {
              console.log('PR body already formatted');
              return;
            }

            // Remove the robot header
            body = body.replace(/^:robot:.*?---\s*/s, '');

            // Parse and reformat the body
            const formattedBody = formatReleaseBody(body);

            if (formattedBody === pr.body) {
              console.log('No changes needed');
              return;
            }

            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              body: formattedBody
            });

            console.log('PR body updated successfully');

            function formatReleaseBody(body) {
              const sections = body.split(/^### /gm);
              const header = sections[0];
              const formattedSections = [header];

              for (let i = 1; i < sections.length; i++) {
                const section = sections[i];
                const lines = section.split('\n');
                const sectionTitle = lines[0].trim();

                if (sectionTitle === 'Features' || sectionTitle === 'Bug Fixes') {
                  formattedSections.push(formatSection(sectionTitle, lines.slice(1)));
                } else {
                  formattedSections.push(section);
                }
              }

              return formattedSections.join('### ');
            }

            function formatSection(title, lines) {
              const items = [];
              let currentItem = '';

              for (const line of lines) {
                if (line.startsWith('* ')) {
                  if (currentItem) items.push(currentItem);
                  currentItem = line;
                } else if (currentItem && line.trim()) {
                  currentItem += '\n' + line;
                } else if (!line.trim() && currentItem) {
                  items.push(currentItem);
                  currentItem = '';
                }
              }
              if (currentItem) items.push(currentItem);

              const grouped = {};
              const noScope = [];

              for (const item of items) {
                const scopeMatch = item.match(/^\* \*\*([a-z][a-z0-9-]*)(?:\([^)]+\))?:\*\*/i);
                if (scopeMatch) {
                  const scope = scopeMatch[1].toLowerCase();
                  if (!grouped[scope]) grouped[scope] = [];
                  const cleanedItem = item.replace(/^\* \*\*[a-z][a-z0-9-]*(?:\([^)]+\))?:\*\*\s*/i, '* ');
                  grouped[scope].push(cleanedItem);
                } else {
                  noScope.push(item);
                }
              }

              let result = title + '\n\n';
              const sortedScopes = Object.keys(grouped).sort();

              for (const scope of sortedScopes) {
                result += `**${scope}:**\n`;
                for (const item of grouped[scope]) {
                  result += item + '\n';
                }
                result += '\n';
              }

              if (noScope.length > 0) {
                if (sortedScopes.length > 0) {
                  result += '**general:**\n';
                }
                for (const item of noScope) {
                  result += item + '\n';
                }
                result += '\n';
              }

              return result;
            }
