<?php

declare(strict_types=1);

namespace Uri;

enum UriComparisonMode
{
    case IncludeFragment;
    case ExcludeFragment;
}

class InvalidUriException extends \Exception
{
}

namespace Uri\WhatWg;

use Uri\UriComparisonMode;

final class Url
{
    public static function parse(string $uri, ?Url $baseUrl = null, ?UrlValidationError &$errors = null): ?self {}

    public function __construct(string $uri, ?Url $baseUrl = null, ?UrlValidationError &$softErrors = null) {}

    public function getScheme(): string {}

    public function withScheme(string $scheme): self {}

    public function getUsername(): ?string {}

    public function withUsername(?string $username): self {}

    public function getPassword(): ?string {}

    public function withPassword(?string $password): self {}

    public function getAsciiHost(): ?string {}

    public function getUnicodeHost(): ?string {}

    public function withHost(?string $host): self {}

    public function getPort(): ?int {}

    public function withPort(?int $port): self {}

    public function getPath(): string {}

    public function withPath(string $path): self {}

    public function getQuery(): ?string {}

    public function withQuery(?string $query): self {}

    public function getFragment(): ?string {}

    public function withFragment(?string $fragment): self {}

    public function equals(Url $url, UriComparisonMode $comparisonMode = UriComparisonMode::ExcludeFragment): bool {}

    public function toAsciiString(): string {}

    public function toUnicodeString(): string {}

    public function resolve(string $uri, ?UrlValidationError &$softErrors = null): self {}

    public function __serialize(): array {}

    public function __unserialize(array $data): void {}

    public function __debugInfo(): array {}
}

class InvalidUrlException extends \Exception
{
    /** @var UrlValidationError[] */
    public array $errors;

    public function __construct(string $message = '', array $errors = [], int $code = 0, ?\Throwable $previous = null) {}
}

enum UrlValidationErrorType
{
    case DomainToAscii;
    case DomainToUnicode;
    case DomainInvalidCodePoint;
    case HostInvalidCodePoint;
    case Ipv4EmptyPart;
    case Ipv4TooManyParts;
    case Ipv4NonNumericPart;
    case Ipv4NonDecimalPart;
    case Ipv4OutOfRangePart;
    case Ipv6Unclosed;
    case Ipv6InvalidCompression;
    case Ipv6TooManyPieces;
    case Ipv6MultipleCompression;
    case Ipv6InvalidCodePoint;
    case Ipv6TooFewPieces;
    case Ipv4InIpv6TooManyPieces;
    case Ipv4InIpv6InvalidCodePoint;
    case Ipv4InIpv6OutOfRangePart;
    case Ipv4InIpv6TooFewParts;
    case InvalidUrlUnit;
    case SpecialSchemeMissingFollowingSolidus;
    case MissingSchemeNonRelativeUrl;
    case InvalidReverseSoldius;
    case InvalidCredentials;
    case HostMissing;
    case PortOutOfRange;
    case PortInvalid;
    case FileInvalidWindowsDriveLetter;
    case FileInvalidWindowsDriveLetterHost;
}

final class UrlValidationError
{
    public readonly string $context;
    public readonly UrlValidationErrorType $type;
    public readonly bool $failure;

    public function __construct(string $context, UrlValidationErrorType $type, bool $failure) {}
}

namespace Uri\Rfc3986;

use Uri\UriComparisonMode;

final class Uri
{
    public static function parse(string $uri, ?Uri $baseUrl = null): ?self {}

    public function __construct(string $uri, ?Uri $baseUrl = null) {}

    public function getScheme(): ?string {}

    public function getRawScheme(): ?string {}

    public function withScheme(?string $scheme): self {}

    public function getUserInfo(): ?string {}

    public function getRawUserInfo(): ?string {}

    public function withUserInfo(?string $userinfo): self {}

    public function getUsername(): ?string {}

    public function getRawUsername(): ?string {}

    public function getPassword(): ?string {}

    public function getRawPassword(): ?string {}

    public function getHost(): ?string {}

    public function getRawHost(): ?string {}

    public function withHost(?string $host): self {}

    public function getPort(): ?int {}

    public function withPort(?int $port): self {}

    public function getPath(): string {}

    public function getRawPath(): string {}

    public function withPath(string $path): self {}

    public function getQuery(): ?string {}

    public function getRawQuery(): ?string {}

    public function withQuery(?string $query): self {}

    public function getFragment(): ?string {}

    public function getRawFragment(): ?string {}

    public function withFragment(?string $fragment): self {}

    public function equals(Uri $uri, UriComparisonMode $comparisonMode = UriComparisonMode::ExcludeFragment): bool {}

    public function toString(): string {}

    public function toRawString(): string {}

    public function resolve(string $uri): self {}

    public function __serialize(): array {}

    public function __unserialize(array $data): void {}

    public function __debugInfo(): array {}
}
